# Authentication Testing
---
## Navigation
- **[Bypassing Authentication Schema](#Bypassing%20Authentication%20Schema)**
- **[Testing for Browser Cache Weaknesses](#Testing%20for%20Browser%20Cache%20Weaknesses)**
---
# Lockout Mechanism
##  CAPTCHA
A CAPTCHA may hinder brute force attacks, but they can come with their own set of weaknesses, and should not replace a lockout mechanism. A CAPTCHA mechanism may be bypassed if implemented incorrectly. CAPTCHA flaws include:
1.  Easily defeated challenge, such as arithimetic or limited question set.
2.  CAPTCHA checks for HTTP **response code **instead of response success.
3.  CAPTCHA server-side logic **defaults to a successful solve**.
4.  CAPTCHA challenge result is **never** validated server-side.
5.  CAPTCHA input field or parameter is manually processed, and is **improperly validated or escaped**.

## To evaluate CAPTCHA effectiveness:
1.  Assess CAPTCHA challenges and attempt **automating solutions depending on difficulty**.
2.  Attempt to submit request **without solving CAPTCHA via the normal UI mechanism(s).**
3.  Attempt to submit request with **intentional CAPTCHA challenge failure.**
4.  Attempt to submit request **without solving CAPTCHA (assuming some default values may be passed by client-side code, etc)** while using a testing proxy (request submitted directly server-side).
5.  Attempt to **fuzz CAPTCHA data entry points (if present) with common injection payloads or special characters sequences**.
6.  Check if the solution to the CAPTCHA might be the alt-text of the image(s), filename(s), or a value in an associated hidden field.
7.  Attempt to re-submit previously identified known good responses.
8.  Check if **clearing cookies causes the CAPTCHA to be bypassed** (for example if the CAPTCHA is only shown after a number of failures).
9.  If the CAPTCHA is part of a multi-step process, **attempt to simply access or complete a step beyond the CAPTCHA (for example if CAPTCHA is the first step in a login process, try simply submitting the second step** [username and password]).
10.  Check for alternative methods that might not have CAPTCHA enforced, such as an API endpoint meant to facilitate mobile app access.

# Bypassing Authentication Schema
### Direct Page Request (Forced browsing)
If the webapp implements  the authentecation  **only** on the login page then you can bypass it by accessing the resource directly.
### Parameter Modification
```bash
#http://www.site.com/page.asp?authenticated=no
raven@blackbox /home $nc www.site.com 80
GET /page.asp?authenticated=yes HTTP/1.0

HTTP/1.1 200 OK
Date: Sat, 11 Nov 2006 10:22:44 GMT
Server: Apache
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
</HEAD><BODY>
<H1>You Are Authenticated</H1>
</BODY></HTML>
```
### Session ID Prediction
If session ID generation is predictable, a malicious user could be able to find a valid session ID and gain unauthorized access to the application, impersonating a previously authenticated user.

![sessionid.png](../assets/WebPentesting/sessionid.png)

### SQL Injection (HTML Form Authentication)
Basic `admin'OR 1=1 --` and it's variations.

# Testing for Browser Cache Weaknesses
### Browser Cache
Here testers check that the application does not leak any sensitive data into the browser cache. In order to do that, they can use a proxy (such as OWASP ZAP or Burpsuite) and search through the server responses that belong to the session, checking that for every page that contains sensitive information the server instructed the browser not to cache any data. Such a directive can be issued in the HTTP response headers with the following directives:

-   `Cache-Control: no-cache, no-store`
-   `Expires: 0`
-   `Pragma: no-cache`

These directives are generally robust, although additional flags may be necessary for the `Cache-Control` header in order to better prevent persistently linked files on the file system. These include:

-   `Cache-Control: must-revalidate, max-age=0, s-maxage=0`

```bash
HTTP/1.1:
Cache-Control: no-cache
```

```bash
HTTP/1.0:
Pragma: no-cache
Expires: "past date or illegal value (e.g., 0)"
```
For instance, if testers are testing an e-commerce application, they should look for all pages that contain a credit card number or some other financial information, and check that all those pages enforce the `no-cache` directive. If they find pages that contain critical information but that fail to instruct the browser not to cache their content, they know that sensitive information will be stored on the disk, and they can double-check this simply by looking for the page in the browser cache.

The exact location where that information is stored depends on the client operating system and on the browser that has been used. Here are some examples:

-   Mozilla Firefox:
    -   Unix/Linux: `~/.cache/mozilla/firefox/`
    -   Windows: `C:\Users\<user_name>\AppData\Local\Mozilla\Firefox\Profiles\<profile-id>\Cache2\`
-   Internet Explorer:
    -   `C:\Users\<user_name>\AppData\Local\Microsoft\Windows\INetCache\`
-   Chrome:
    -   Windows: `C:\Users\<user_name>\AppData\Local\Google\Chrome\User Data\Default\Cache`
    -   Unix/Linux: `~/.cache/google-chrome`

Additionally, personal proxies such as ZAP and Burp Suite allow the tester to specify which `User-Agent` should be sent by their spiders/crawlers. This could be set to match a mobile browser `User-Agent` string and used to see which caching directives are sent by the application being tested.

# Loose comparison
- Registering a new user `Admin` may give you access to `admin` account when logging in. -> [Reference](https://pentesterlab.com/exercises/authe_03/course) 
- Adding space before or after the username, MYSQL ignores trailing spaces. -> [Reference + mitigation](https://pentesterlab.com/exercises/authe_04/course)
