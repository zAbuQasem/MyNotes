#!/usr/bin/env python3
"""
Improve web-pentesting notes structure:
- Fix heading alignment (remove extra spaces)
- Add code blocks where needed
- Remove duplicate content
- Ensure consistent structure
"""

import os
import re
from pathlib import Path
from typing import List, Tuple

class WebPentestingImprover:
    def __init__(self, web_dir: str = "notes/web-pentesting"):
        self.web_dir = Path(web_dir).resolve()
        self.files_modified = []
        
    def fix_heading_spacing(self, content: str) -> Tuple[str, List[str]]:
        """Fix headings with extra spaces."""
        changes = []
        lines = content.split('\n')
        new_lines = []
        
        for line in lines:
            # Fix headings with multiple spaces after #
            if re.match(r'^(#{1,6})\s{2,}', line):
                fixed_line = re.sub(r'^(#{1,6})\s{2,}', r'\1 ', line)
                changes.append(f"Fixed heading spacing: '{line.strip()}' → '{fixed_line.strip()}'")
                new_lines.append(fixed_line)
            else:
                new_lines.append(line)
        
        return '\n'.join(new_lines), changes
    
    def add_code_blocks(self, content: str) -> Tuple[str, List[str]]:
        """Add code blocks where text looks like code but isn't in a block."""
        changes = []
        lines = content.split('\n')
        new_lines = []
        i = 0
        in_code_block = False
        
        while i < len(lines):
            line = lines[i]
            
            # Track if we're in a code block
            if line.strip().startswith('```'):
                in_code_block = not in_code_block
                new_lines.append(line)
                i += 1
                continue
            
            # Skip if already in code block
            if in_code_block:
                new_lines.append(line)
                i += 1
                continue
            
            # Check for lines that look like commands/code but aren't in blocks
            # Look for patterns like:
            # - Lines starting with $ or # (shell commands)
            # - HTTP requests/responses
            # - SQL queries
            # But only if they're not already formatted
            
            if self._looks_like_code(line) and not self._is_list_item(line):
                # Check if next few lines are also code-like
                code_lines = [line]
                j = i + 1
                while j < len(lines) and (self._looks_like_code(lines[j]) or lines[j].strip() == ''):
                    code_lines.append(lines[j])
                    j += 1
                    if lines[j-1].strip() == '' and (j >= len(lines) or not self._looks_like_code(lines[j])):
                        break
                
                if len(code_lines) > 1 or self._definitely_code(line):
                    # Add code block
                    lang = self._detect_language(code_lines)
                    new_lines.append(f'```{lang}')
                    new_lines.extend(code_lines)
                    new_lines.append('```')
                    changes.append(f"Added code block at line {i+1}")
                    i = j
                    continue
            
            new_lines.append(line)
            i += 1
        
        return '\n'.join(new_lines), changes
    
    def _looks_like_code(self, line: str) -> bool:
        """Check if a line looks like code."""
        stripped = line.strip()
        if not stripped:
            return False
        
        # Patterns that indicate code
        code_patterns = [
            r'^(GET|POST|PUT|DELETE|HEAD|OPTIONS|PATCH)\s+',  # HTTP methods
            r'^HTTP/\d',  # HTTP response
            r'^\$\s',  # Shell prompt
            r'^>\s',  # Command output
            r'^SELECT\s+', r'^INSERT\s+', r'^UPDATE\s+', r'^DELETE\s+',  # SQL
            r'<\?php',  # PHP
            r'^import\s+', r'^from\s+.+import',  # Python
            r'^\w+\s*=\s*.+[;{]$',  # Assignments with ; or {
        ]
        
        return any(re.match(pattern, stripped, re.IGNORECASE) for pattern in code_patterns)
    
    def _definitely_code(self, line: str) -> bool:
        """Check if line is definitely code (not prose)."""
        stripped = line.strip()
        return (stripped.startswith('$') or 
                stripped.startswith('curl ') or
                re.match(r'^(GET|POST|PUT|DELETE)\s+', stripped))
    
    def _is_list_item(self, line: str) -> bool:
        """Check if line is a list item."""
        stripped = line.lstrip()
        return stripped.startswith(('-', '*', '+')) or re.match(r'^\d+\.', stripped)
    
    def _detect_language(self, lines: List[str]) -> str:
        """Detect programming language from code lines."""
        text = ' '.join(lines).lower()
        
        if 'http/' in text or any(method in text for method in ['get ', 'post ', 'put ', 'delete ']):
            return 'http'
        elif 'select ' in text or 'insert ' in text or 'update ' in text:
            return 'sql'
        elif '<?php' in text:
            return 'php'
        elif 'import ' in text or 'def ' in text:
            return 'python'
        elif '$' in text:
            return 'bash'
        else:
            return 'text'
    
    def remove_duplicate_headings(self, content: str) -> Tuple[str, List[str]]:
        """Remove duplicate consecutive headings."""
        changes = []
        lines = content.split('\n')
        new_lines = []
        prev_heading = None
        
        for i, line in enumerate(lines):
            if re.match(r'^#{1,6}\s+', line):
                heading_text = re.sub(r'^#{1,6}\s+', '', line).strip()
                if heading_text == prev_heading:
                    changes.append(f"Removed duplicate heading at line {i+1}: '{line.strip()}'")
                    continue
                prev_heading = heading_text
            else:
                prev_heading = None
            
            new_lines.append(line)
        
        return '\n'.join(new_lines), changes
    
    def fix_file(self, filepath: Path) -> Tuple[bool, List[str]]:
        """Fix a single file."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            original_content = content
            all_changes = []
            
            # Apply fixes in order
            content, changes = self.fix_heading_spacing(content)
            all_changes.extend(changes)
            
            content, changes = self.remove_duplicate_headings(content)
            all_changes.extend(changes)
            
            # Note: add_code_blocks is commented out as it might be too aggressive
            # content, changes = self.add_code_blocks(content)
            # all_changes.extend(changes)
            
            # Write back if changed
            if content != original_content:
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                return True, all_changes
            
            return False, []
            
        except Exception as e:
            print(f"Error processing {filepath}: {e}")
            return False, []
    
    def process_all_files(self):
        """Process all markdown files in web-pentesting."""
        markdown_files = []
        for filepath in self.web_dir.rglob("*.md"):
            if filepath.name.lower() != 'readme.md':  # Skip readme
                markdown_files.append(filepath)
        
        print(f"Found {len(markdown_files)} markdown files to process\n")
        
        for filepath in sorted(markdown_files):
            modified, changes = self.fix_file(filepath)
            
            if modified:
                rel_path = filepath.relative_to(self.web_dir.parent)
                print(f"✅ Fixed: {rel_path}")
                for change in changes:
                    print(f"   - {change}")
                self.files_modified.append(filepath)
        
        print(f"\n✨ Complete! Modified {len(self.files_modified)} files")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Improve web-pentesting notes structure'
    )
    parser.add_argument(
        '--web-dir',
        default='notes/web-pentesting',
        help='Web pentesting directory (default: notes/web-pentesting)'
    )
    
    args = parser.parse_args()
    
    improver = WebPentestingImprover(web_dir=args.web_dir)
    improver.process_all_files()


if __name__ == '__main__':
    main()
